---
layout: post
title:  "0x07 - Things I've learned about lwIP"
date:   2024-09-07 20:39:00 +0100
categories: lwip
---

I've been using lwip's raw TCP stack in anger over the past year or so and had idea to document some useful information I've discovered when using it. I've mostly been using the official documentation[^1] as well as a fandom.com[^2] page I came across.

# What the hell is LWIP?

It stands for _Lightweight Internet Protocol_ and is a minimal TCP/IP stack designed for use on embedded platforms[^1]. I've mostly been using the raw TCP functionality for sending and receiving MQTT data to/from a broker on a local network using a Raspberry Pi Pico W (henceforth known as 'pico' in this article).

# Preliminary info
When using lwip on a pico W there are three ways you can use it which are _poll_, _thread safe background_ and , _freertos_ [^3]. For my applications I use the _thread safe background_, where lwIP tasks are executed in an interrupt routine. The Pico SDK documentation states that when lwIP is used with this configuration, all calls into lwip need to be within cyw43_arch_lwip_begin() and cyw43_arch_lwip_end() blocks as the library **is not thread safe**[^3]. These functions act as a Critical Section to prevent lwIP's internals getting trashed because of buffer access via interrupt-context and normal-context. Inspecting the SDK you can see that these functions call into functions that block other contexts from accessing the lwip resources while the given context is using it [^4].


# Initialising
Initialising the raw TCP stack begins with a call to `tcp_new()` which creates a new instance of the TCP PCB (protocol control block). I found that this function would fail if I hadn't properly freed the previous instances when 
attempting to restart the connection. Presumably the other PCB's were still being handled by lwIP and it had ran out of memory.

```
cyw43_arch_lwip_begin()
static struct tcp_pcb * tcp_pcb = tcp_new();
cyw43_arch_lwip_end()
if(tcp_pcb == NULL)
{
    /* Something iffy with memory */
    assert(false);
}
```

Once an acquired PCB has been acquired you can then attempt to establish a connection. In my application I'm connecting to a local server which has a fixed IP, so there is no need to perform any DNS requests to resolve a domain name.  However if the ip is stored in a string you'll need to convert it from the ascii for (with dot notation) to network byte order[^5] [^6] format using the following example code:

```
ip_addr_t remote_addr;
char * broker_ip = "192.168.1.101"
ip4addr_aton((char*)broker_ip, &remote_addr);
```


# References
[^1]: lwIP - A Lightweight TCP/IP stack - Summary [link](https://savannah.nongnu.org/projects/lwip/)
[^2]: Fandom.com - lwIP wiki [link](https://lwip.fandom.com/wiki/Raw/TCP)
[^3]: Raspberry Pi Documentation - pico_cyw43_arch [link](https://www.raspberrypi.com/documentation/pico-sdk/networking.html#pico_cyw43_arch)
[^4]: Github - Pico SDK [link](https://github.com/raspberrypi/pico-sdk/blob/efe2103f9b28458a1615ff096054479743ade236/src/rp2_common/pico_cyw43_arch/include/pico/cyw43_arch.h#L277)
[^5]: Beej's guide to networking [link](https://beej.us/guide/bgnet/html/index-wide.html#inet_ntoaman)
[^6]: inet_aton(3) - Linux man page [link](https://linux.die.net/man/3/inet_aton)
